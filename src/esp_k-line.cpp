#include <Arduino.h>
#include <ESP8266WiFi.h>
#include <ESP8266WebServer.h>
#include <ESP8266HTTPUpdateServer.h>
#include "LittleFS.h"
#include <GyverOLED.h>
#include <pgmspace.h>

const char *ssid = "K-Line_Adapter";
const char *password = "12345678";
const uint8_t anime[] PROGMEM = {
	0x04, 0x06, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xF0, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFE, 0xF8, 0xE0, 0xC0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x1F, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFC, 0xF8, 0xF0, 0xE0, 0xC0, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFE, 0xFF, 0xFF, 0xFF, 0xFF, 0xFE, 0xF8, 0xF0, 0xF1, 0xE3, 0xC7, 0x9F, 0x3F, 0x7F, 0xFE, 0xFE, 0xFC, 0xFC, 0xF8, 0xF0, 0xF0, 0xE0, 0xE0, 0xC0, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x7C, 0xFE, 0xFF, 0xFE, 0xFC, 0xF0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x1C, 0xE0, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x09, 0xFD, 0xFC, 0xFC, 0xFC, 0xFC, 0xFC, 0xFC, 0xFD, 0xF9, 0xF8, 0xF8, 0xF8, 0xF0, 0x84, 0x18, 0x70, 0xC0, 0x1B, 0x77, 0xEF, 0xDF, 0xBF, 0x7F, 0x7F, 0xFF, 0xFF, 0xFF, 0xFF, 0xFE, 0xFC, 0xF8, 0xF8, 0xF0, 0x00, 0x00, 0x80, 0x8C, 0x1F, 0x3F, 0x7F, 0xEF, 0xE7, 0xF7, 0x7B, 0x7B, 0x39, 0x3D, 0x1C, 0x0E, 0x06, 0x06, 0x86, 0x05, 0x43, 0x03, 0x03, 0x03, 0x83, 0x41, 0x21, 0x85, 0xF5, 0x76, 0x74, 0xB0, 0xC0, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x0F, 0xFF, 0x87, 0xFF, 0xFE, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0xFF, 0x81, 0xF5, 0xF5, 0xF1, 0xFF, 0x81, 0xF5, 0xF5, 0xFF, 0x81, 0xF5, 0xF5, 0xFF, 0xFD, 0xFD, 0x81, 0xFD, 0xFD, 0xFF, 0xBF, 0xFF, 0xBF, 0xFF, 0x00, 0x00, 0x00, 0x00, 0xBF, 0xBF, 0xFF, 0xFF, 0xFF, 0xFF, 0xEF, 0xEF, 0xEF, 0x6F, 0x6F, 0x6F, 0x4F, 0x5F, 0xDF, 0xFE, 0xFC, 0xFB, 0xF6, 0xE5, 0xFF, 0xFF, 0xFF, 0xFF, 0xFE, 0xFE, 0xFD, 0xFD, 0xFF, 0xBF, 0xDF, 0xEF, 0xF3, 0xFC, 0xFE, 0xFF, 0xFF, 0xFE, 0xF8, 0xFE, 0xFE, 0xFD, 0xF2, 0xF9, 0xFC, 0xFC, 0xFC, 0xFE, 0xFF, 0xFF, 0xDE, 0xFC, 0xDD, 0xDC, 0xDC, 0xDC, 0xED, 0xEC, 0xF6, 0xFB, 0xFD, 0xFE, 0x7F, 0xBF, 0xFF, 0xFF, 0xFF, 0xFC, 0xC0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3F, 0x1F, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x01, 0x03, 0x03, 0x07, 0x06, 0x0C, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x73, 0xC3, 0x63, 0xE3, 0xE1, 0xE1, 0xE0, 0xF0, 0xF0, 0xE0, 0xC8, 0xD0, 0x84, 0x80, 0x80, 0x80, 0x80, 0x50, 0xE8, 0xA3, 0xEF, 0xEF, 0xFF, 0xFF, 0x7F, 0xFF, 0xFF, 0xFF, 0x3F, 0xFF, 0xFF, 0x7F, 0xDF, 0xFF, 0xBF, 0xEF, 0xFF, 0xDF, 0xF7, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xDF, 0xEF, 0xF7, 0xDB, 0xED, 0xF6, 0xFB, 0xFD, 0xF6, 0xFB, 0xFD, 0xFE, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xE0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFC, 0xFC, 0xF0, 0xE0, 0x00, 0x00, 0xF8, 0xF8, 0xF0, 0x8F, 0x3F, 0xFF, 0xFD, 0xFD, 0xFD, 0xFD, 0xFD, 0x7D, 0xBD, 0xDD, 0x6D, 0xBD, 0xDE, 0xEE, 0xF6, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFE, 0xFF, 0xFF, 0xFF, 0xFE, 0xFF, 0xFF, 0xF0, 0xCF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x38, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xF0, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFE, 0xF8, 0x03, 0x0F, 0x7F, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xF7, 0xEF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x7F, 0x0F, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 
	0x40, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xC0, 0x3C, 0xC0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x7F, 0xFF, 0xFF, 0xFF, 0xFF, 0xC0, 0x3F, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xF0, 0x00, 0x00, 0x01, 0x03, 0x0F, 0x1F, 0x3F, 0x7F, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x7F, 0x7F, 0x3F, 0xBF, 0xBF, 0xBF, 0xBF, 0x3F, 0x7F, 0x7F, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x3F, 0x07, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xC0, 0x38, 0x86, 0x78, 0x00, 0xC0, 0x3F, 
	0x00, 0x03, 0x0C, 0xF0, 0x00, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x01, 0x3E, 0xC0, 0x00, 0x00, 0x00, 0x00, 0x00, 0xF0, 0x08, 0x70, 0x80, 0x01, 0x07, 0x0F, 0x3F, 0xFF, 0xFE, 0xF1, 0x8F, 0x7F, 0xFF, 0xFF, 0xFF, 0xFC, 0xF8, 0xF0, 0xE0, 0xC0, 0x80, 0x00, 0x00, 0x00, 0x01, 0x03, 0x07, 0x0F, 0x1F, 0x1F, 0x3F, 0x7F, 0x7F, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xF9, 0xFB, 0xFB, 0xBB, 0xB1, 0x70, 0x72, 0x71, 0x79, 0xB9, 0xBA, 0xDA, 0xFD, 0xFD, 0xFD, 0xFE, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x7F, 0xBF, 0xDF, 0xEF, 0xF7, 0xF9, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xC0, 0x30, 0x0C, 0x03, 0x3C, 0xC0, 0x3E, 0x01, 0xFE, 0x00, 0xC0, 0x20, 0x10, 0x0F, 0xE0, 0x9C, 0x43, 0x30, 0x0C, 0x03, 0x00, 
};

ESP8266WebServer server(80);
ESP8266HTTPUpdateServer httpUpdater;
String serialData;
unsigned long lastUpdate = 0;

// Настройки OLED дисплея
GyverOLED<SSD1306_128x64> oled;

// Функции для работы с OLED дисплеем

// Функции для работы с KWP2000
String createKwpFrame(const String &command)
{
  String cleanCommand = command;
  cleanCommand.replace(" ", "");
  int dataLen = cleanCommand.length() / 2;

  if (dataLen == 0 || cleanCommand.length() % 2 != 0)
  {
    return "";
  }

  // Проверка максимальной длины (согласно спецификации)
  if (dataLen > 63)
  {
    return ""; // Для 3-байтного заголовка максимум 63 байта данных
  }

  String frame = "";

  // ПРАВИЛЬНЫЙ расчет байта формата:
  // A1,A0 = 10 (физическая адресация) + длина поля данных
  byte formatByte = 0x80 | dataLen; // 0x80 = 10000000 (A1=1, A0=0)
  frame += (char)formatByte;
  frame += (char)0x10; // Адрес получателя (ECU)
  frame += (char)0xF1; // Адрес отправителя (тестер)

  // Добавление данных
  for (int i = 0; i < dataLen; i++)
  {
    String byteStr = cleanCommand.substring(i * 2, i * 2 + 2);
    byte dataByte = (byte)strtol(byteStr.c_str(), NULL, 16);
    frame += (char)dataByte;
  }

  // Контрольная сумма
  byte checksum = 0;
  for (size_t i = 0; i < frame.length(); i++)
  {
    checksum += frame[i];
  }
  frame += (char)checksum;

  return frame;
}

bool validateKwpChecksum(const String &frame)
{
  if (frame.length() < 2)
    return false;

  byte checksum = 0;
  for (size_t i = 0; i < frame.length() - 1; i++)
  {
    checksum += frame[i];
  }

  return (byte)frame[frame.length() - 1] == checksum;
}

String sendKwpCommand(const String &command, unsigned long minLength, unsigned long timeout)
{
  String frame = createKwpFrame(command);
  if (frame.length() == 0)
  {
    return "";
  }

  // Очистка буфера
  while (Serial.available())
  {
    Serial.read();
  }

  // Отправка команды
  Serial.print(frame);

  // Ожидание ответа
  String response = "";
  unsigned long startTime = millis();

  while (millis() - startTime < timeout)
  {
    if (Serial.available())
    {
      char c = Serial.read();
      response += c;

      if (response.length() >= minLength)
      {
        if (validateKwpChecksum(response))
        {
          return response;
        }
      }
    }
  }

  return "";
}

bool init_conn()
{
  String response;

  // 1. Start Communication
  response = sendKwpCommand("81", 6, 1500);
  if (response.length() == 0 || !validateKwpChecksum(response) || (byte)response[3] != 0xC1)
  {
    return false;
  }

  // 2. Start Diagnostic Session
  response = sendKwpCommand("10 81 0A", 5, 1500);
  if (response.length() == 0 || !validateKwpChecksum(response) || (byte)response[3] != 0x50)
  {
    return false;
  }

  // 3. Verify connection with Tester Present
  response = sendKwpCommand("3E", 4, 1000);
  if (response.length() == 0 || !validateKwpChecksum(response) || (byte)response[3] != 0x7E)
  {
    return false;
  }

  return true;
}

// Функция для поддержания связи (вызывать в loop)
bool maintain_kwp_connection()
{
  static unsigned long lastKeepAlive = 0;

  if (millis() - lastKeepAlive > 2000)
  {
    sendKwpCommand("3E 80", 0, 100); // Отправляем без ожидания ответа
    lastKeepAlive = millis();
    return true;
  }
  return true;
}

String toHexString(const String &data)
{
  String result;
  result.reserve(data.length() * 3);

  for (size_t i = 0; i < data.length(); i++)
  {
    if (i > 0)
      result += " ";
    char buf[3];
    sprintf(buf, "%02X", (unsigned char)data[i]);
    result += buf;
  }
  return result;
}

String parseKwpFrame(const String &frame)
{
  if (frame.length() < 5)
    return "Invalid frame: too short";

  String result;
  result.reserve(150);

  // Проверка контрольной суммы
  byte checksum = 0;
  for (size_t i = 0; i < frame.length() - 1; i++)
  {
    checksum += frame[i];
  }

  if ((byte)frame[frame.length() - 1] != checksum)
  {
    return "Checksum error";
  }

  // Анализ байта формата
  byte formatByte = frame[0];
  byte addressMode = (formatByte >> 6) & 0x03; // Биты 7-6
  byte dataLength = formatByte & 0x3F;         // Биты 5-0

  result += "Format: 0x";
  char buf[10];
  sprintf(buf, "%02X", formatByte);
  result += buf;
  result += " (Mode: ";
  result += String(addressMode);
  result += " Len: ";
  result += String(dataLength);
  result += ") ";

  // Проверка типа заголовка
  if (addressMode != 0x02)
  { // 10 = физическая адресация (из спецификации)
    result += "Unsupported address mode";
    return result;
  }

  // Для 3-байтного заголовка (физическая адресация)
  if (frame.length() != dataLength + 4)
  { // Fmt+Tgt+Src+Data+CS
    result += "Length mismatch";
    return result;
  }

  byte targetAddr = frame[1];
  byte sourceAddr = frame[2];

  result += "Target: 0x";
  sprintf(buf, "%02X", targetAddr);
  result += buf;

  result += " Source: 0x";
  sprintf(buf, "%02X", sourceAddr);
  result += buf;

  // Проверка адресов по спецификации
  if (targetAddr != 0x10)
  {
    result += " [Invalid ECU addr]";
  }
  if (sourceAddr != 0xF1 && sourceAddr != 0xC0)
  { // F1=тестер, C0=иммобилайзер
    result += " [Invalid source addr]";
  }

  result += " Data: ";
  for (size_t i = 3; i < frame.length() - 1; i++)
  {
    sprintf(buf, "%02X ", (unsigned char)frame[i]);
    result += buf;
  }

  return result;
}

String getTime()
{
  unsigned long seconds = millis() / 1000;
  unsigned long minutes = seconds / 60;
  unsigned long hours = minutes / 60;
  seconds %= 60;
  minutes %= 60;
  char buf[10];
  sprintf(buf, "%02lu:%02lu:%02lu", hours, minutes, seconds);
  return String(buf);
}

// Функции для работы с веб-сервером
void handleRoot()
{
  File file = LittleFS.open("/index.html", "r");
  if (!file)
  {
    server.send(500, "text/plain", "Ошибка открытия файла");
    return;
  }

  server.streamFile(file, "text/html");
  file.close();
}

void handleCSS()
{
  File file = LittleFS.open("/style.css", "r");
  if (!file)
  {
    server.send(404, "text/plain", "File not found");
    return;
  }

  server.streamFile(file, "text/css");
  file.close();
}

void handleNotFound()
{
  String message = "File Not Found\n\n";
  server.send(404, "text/plain", message);
}

void handleData()
{
  server.send(200, "text/html", serialData);
}

void handleSend()
{
  if (server.hasArg("cmd"))
  {
    String command = server.arg("cmd");
    String kwpFrame = createKwpFrame(command);

    if (kwpFrame.length() == 0)
    {
      server.send(400, "text/plain", "Invalid command");
      return;
    }

    for (size_t i = 0; i < kwpFrame.length(); i++)
    {
      Serial.print(kwpFrame[i]);
    }

    String timeStr = getTime();
    String logEntry = "[" + timeStr + "] TX: " + command + " (Frame: " + toHexString(kwpFrame) + ")";
    serialData += logEntry + "<br>";

    // Ограничиваем размер serialData чтобы избежать переполнения памяти
    if (serialData.length() > 4000)
    {
      int cutIndex = serialData.indexOf('<', 1000);
      if (cutIndex != -1)
      {
        serialData = serialData.substring(cutIndex);
      }
    }

    oled.print("TX:" + command + toHexString(kwpFrame));
    oled.update();
  }
  server.send(200, "text/plain", "OK");
}

void handleClear()
{
  serialData = "Лог очищен<br>";
  oled.clear();
  oled.print("Log clear");
  oled.update();
  server.send(200, "text/plain", "OK");
}

void setup()
{
  Serial.begin(10400);
  delay(1000);

  // Резервируем память для serialData
  serialData.reserve(5000);

  // Инициализация OLED дисплея
  oled.init();
  oled.flipH(true);
  oled.flipV(true);

  // Показываем заставку при включении
  oled.clear();
  oled.drawBitmap(0, 0, anime, 128, 64);
  oled.update();
  delay(2000); // Показываем заставку 2 секунды

  // Инициализация файловой системы
  if (!LittleFS.begin())
  {
    oled.print("Ошибка файловой системы");
    // Продолжаем работу даже без файловой системы
  }

  // Настройка WiFi
  WiFi.softAP(ssid, password);
  IPAddress myIP = WiFi.softAPIP();

  // Настройка сервера
  httpUpdater.setup(&server, "/firmware", "admin", "12345");
  server.on("/", handleRoot);
  server.on("/data", handleData);
  server.on("/send", handleSend);
  server.on("/clear", handleClear);
  server.on("/style.css", handleCSS);
  server.onNotFound(handleNotFound);
  server.begin();

  // Обслуживание статических файлов
  server.serveStatic("/style.css", LittleFS, "/style.css");
  server.serveStatic("/script.js", LittleFS, "/script.js");

  // Добавляем начальное сообщение
  serialData = "K-Line launch<br>";
  serialData += "IP адрес: " + myIP.toString() + "<br>";
  serialData += "Speed: 10400 baud<br>";
  serialData += "Protocol: KWP2000<br>";

  oled.clear();
  oled.setScale(2);
  oled.setCursor(20, 1);
  oled.print("ВКЛЮЧИТЕ");
  oled.setCursor(14, 4);
  oled.print("ЗАЖИГАНИЕ");
  oled.update();
  delay(5000); // Показываем заставку 2 секунды

  if (init_conn())
  {
    // Соединение установлено
    oled.clear();
    oled.setCursor(35, 0);
    oled.print("ОТВЕТ");
    oled.setCursor(30, 3);
    oled.print("ОТ ЭБУ");
    oled.setCursor(25, 6);
    oled.print("ПОЛУЧЕН");
    oled.update();
    oled.setScale(1);
    delay(2000); // Показываем заставку 2 секунды
    maintain_kwp_connection();
  }
  else
  {
    // Ошибка подключения
    oled.clear();
    oled.setCursor(30, 0);
    oled.print("ОШИБКА");
    oled.setCursor(25, 3);
    oled.print("СВЯЗИ С");
    oled.setCursor(50, 6);
    oled.print("ЭБУ");
    oled.update();
    oled.setScale(1);
    delay(2000); // Показываем заставку 2 секунды
  }
}

void loop()
{
  server.handleClient();

  // Чтение данных из последовательного порта
  if (Serial.available() > 0)
  {
    String data = Serial.readString();
    String timeStr = getTime();
    String logEntry = "[" + timeStr + "] RX: " + toHexString(data);
    serialData += logEntry + "<br>";

    // Ограничиваем размер serialData чтобы избежать переполнения памяти
    if (serialData.length() > 4000)
    {
      int cutIndex = serialData.indexOf('<', 1000);
      if (cutIndex != -1)
      {
        serialData = serialData.substring(cutIndex);
      }
    }

    // Добавляем на дисплей (обрезаем до 21 символа)
    String displayLine = "RX: " + toHexString(data);
    oled.print(displayLine);
  }

  delay(10);
}